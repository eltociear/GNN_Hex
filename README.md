# GABOR
**G**r**A**ph **B**ased b**O**ard game solve**R**

## Introduction
I was interested in solving the game [Qango](http://qango.de/index.html?page=spiel&language=englisch). Qango is a two player, zero sum, perfect knowlege game, which is equivalent to a bigger version of [tic tac toe](https://de.wikipedia.org/wiki/Tic-Tac-Toe) with different winning conditions. To solve the game I decided to use a [proof-number search](https://www.chessprogramming.org/Proof-Number_Search) as the game includes a lot of forced variations. If you just wan't to check out the results, go to [yannikkeller.de](http://yannikkeller.de/qango/game_solver/page/playme.html) and get beaten down by the perfect ai. You can also just explore the winning moves [here](http://yannikkeller.de/qango/game_solver/page/explore_wins.html).

## Rules of Qango
There are two different versions of Qango, the 6x6 version and the 7x7 version. My software focusses on solving the 6x6 version. Just like in tic tac toe, the players take alternating turns occupying squares until one of them achieves a winning pattern. Instead of marking them with X and O's, the players use white and black stones to mark theire squares. In Qango, there are the following winning patterns:
1. A 5 stone row, horizontally, vertically or diagonally
2. A 2x2 square
3. 3 contiguous squares of the same color (The Qango board is colored, click [here](http://yannikkeller.de/qango/game_solver/page/playme.html) to check out the color patterns)

As for advanced players, it becomes very obvious, that the game is winning for the first player in it's normal state, there is an additional Rule for advanced players called [Burgregel](http://qango.de/index.html?page=fortgeschrittene&language=deutsch). With this Rule, the first player isn't allowed to occupy the 4 squares in the center or the 4 squares in the 2-2 position in the first move (check out the black X-es in the beginning of the game when playing on [yannikkeller.de](http://yannikkeller.de/qango/game_solver/page/playme.html)).
A long time ago, I had already suspected, that the game would still be a first player win, even when using the *Burgregel*. In fact, I was able to finally proove it using this software.

## Implementation
I implemented the Software in Python3, because Python is just such an easy to use high level language I love to use for just about any problem. Looking at it afterwards, I have to admit, that this was probably not the best decision to make. As Python is such a high level language, efficient working memory handeling is very hard in Python. As this is most limiting factor to the Proof-Number search, this is a real problem. In hindsight, it would probably have been a better choice to choose a lower level Language like C++.
To be real fast while going through the variations of the game, I implemented Qango in terms of bitwise operations. The position can be represented using two 64 bit integers, one for the first players Stone, the other for the second players Stones. The set bits in the integer then represent which squares have been occupied by that player. Finding out what moves are allowed in a position is then just a matter of or-ing two integers and then forming the complement.
When I then implemented the basic version of the Proof-Number search algorithm, I had to find out, that this was not even enough to solve the basic version of Qango. So I had to make the following improvements:
1. **Make use of symetries and transpositions:** As each Qango position can be represented in 8 symetrical ways and positions can be reached through multiple paths, it would be stupid not to make use of that. So I read this [Paper](https://pdfs.semanticscholar.org/86f5/1429a19cfc76e9d42f28b93c62e978c816a0.pdf) and transformed my game tree into a directed acyclic graph.
2. **Move ordering:** In Qango, the squares in the center, are much more likely to be usefull to occupy, than the squares in the corner. So it was important to make sure, that when there is a tie in the Proof-Number of two nodes, the algorithm first checks out the move closer to the center.
3. **Deleting proven nodes:** Using above techniques, I was already able to solve the basic version of the Game in just a few seconds, but when trying with the *Burgregel*, I still ran out of memory. So I make use of a technique first described by Victor Allis and deleted all Nodes that where already proven from the game tree. The hash of their position is stored in either the *provenset* or the *disprovenset*, so I don't have to evaluate the positions again, when I reach them.

## If you wan't to clone this repository
Feel free to clone this repository and check out the code yourself, but be warned: As I implemented the code just for myself, I didn't do any documentation or commenting and the code will probably be very hard to understand for someone, who has not implemented it himself.

## Further work
As some other Qango players have also figured out, that the *Burgregel* is still a first player win. At some of the Qango tournaments, they have started to play with the inofficial *6x6 Profiregel*. Here the first player has to start on the edge of the board. It would be interesting to find out the game theoretical value of this way to play.
Also, there is still the 7x7 version of the game, I haven't touched yet at all. As solving 6x6 Qango is much easier, as solving 7x7 Qango, this will probably only be possible with a better Computer and a memory efficient in C++. Also, I might need to look into some more sophisticated approaches as [PNÂ²](https://www.researchgate.net/publication/292699512_The_PN2-search_algorithm) or PDS-PN.